# Rétrospective — Épic 1 : Structure, Navigation et Persistance
**Date :** 2026-02-25
**Facilitation :** Bob (Scrum Master)
**Participants :** Bob (SM), Alice (PO), Charlie (Dev), Dana (QA), Winston (Architecte), Nico (Project Lead)

---

## Résumé de l'Épic

| Métrique | Valeur |
|----------|--------|
| Stories complétées | 4/4 (100%) |
| Tests passés (fin d'épic) | 50/50 |
| Progression tests | 27 → 44 → 50 |
| Build fails | 0 |
| Régressions | 0 |
| Issues code review résolues | ~16 (6 HIGH/MEDIUM + 10 LOW) |
| Dette technique acceptée | 3 items |
| Incidents de production | 0 (app non déployée) |

**Stories livrées :**
- 1.1 — Initialisation du projet et schéma SwiftData ✅
- 1.2 — Dashboard et navigation hiérarchique ✅
- 1.3 — Création d'une tâche avec détection de doublons ✅
- 1.4 — Archivage des tâches terminées ✅

---

## Ce qui a bien marché

- **Zéro build fail** sur toute la durée de l'épic — remarquable en Swift 6 language mode avec 11 entités SwiftData créées from scratch
- **50 tests passés, zéro régression** — chaque story a ajouté de la couverture sans casser l'existant
- **Pattern injection établi** (BriefingEngine injectable via `init(similarityFn:)`) — les 14 tests du service tournent sans NLEmbedding ni pack linguistique
- **Bug de navigation détecté et résolu dans l'épic** — `.navigationDestination(for:)` enregistré à plusieurs niveaux créait des destinations ambiguës et des boucles infinies ; résolu par navigation directe
- **Architecture MVVM respectée** — `ModelContext` toujours injecté via `init`, jamais de `@Query` dans les Views
- **Test manuel de Nico** — seul moyen d'attraper les bugs de navigation visuelle que les tests automatisés ne peuvent pas détecter

---

## Ce qui était difficile

### 1. Violations des règles non-négociables au premier jet
- `try?` silencieux au lieu de `try` explicite en story 1.1 (corrigé en revue d'intégration)
- `PauseBannerView` écrivait directement dans `chantier.isBrowsing` au lieu de passer par `reprendreDepuisPause()` en story 1.2 (violation frontière architecturale View → State)
- **Pattern :** les règles non-négociables sont respectées après revue mais pas toujours au premier jet

### 2. Tests de cas d'erreur systématiquement sous-représentés
- Story 1.2 : aucun test de cas `.failure` au premier jet (ajouté après review)
- Story 1.4 : test `archivedTaskNotDuplicate` bidon remplacé par `archiverRollsBackOnSaveFailure` (rollback in-memory sur échec save)
- **Pattern :** le happy path est bien couvert, les edge cases et rollbacks sont oubliés au premier jet

### 3. Navigation SwiftUI — piège `.navigationDestination(for:)`
- Comportement indéfini quand le même type est enregistré à plusieurs niveaux de la hiérarchie
- Résultat : boucle infinie (list → list → list) au lieu de list → detail
- Découvert uniquement par test manuel — non détectable par tests automatisés

### 4. Courbe d'apprentissage Swift 6
- `lazy var` incompatible avec `@Observable` (Story 1.3)
- `SWIFT_DEFAULT_ACTOR_ISOLATION = MainActor` impacte la structure des tests
- NLEmbedding retourne une distance cosinus [0,2] et non une similarité [0,1] — conversion manuelle requise
- Dict keys NLEmbedding doivent être lowercase

---

## Insights clés

1. **Le test manuel est irremplaçable** — les tests unitaires ne voient pas le comportement de navigation visuelle
2. **Les règles non-négociables doivent être une checklist active** — pas un document lu une fois
3. **Centraliser les mutations d'état partagé dans des méthodes nommées** (`reprendreDepuisPause()`) — pattern à généraliser pour l'Épic 2 où `ModeChantierState` va devenir bien plus riche
4. **Swift 6 est strict mais prévisible** — les Technical Notes précises dans les stories ont évité les surprises de compilation

---

## Analyse de la dette technique acceptée

| Item | Story | Décision | Impact Épic 2 |
|------|-------|----------|---------------|
| NFR-P1 ≤ 1s non validé sur device physique | 1.1 | Accepté — à valider sur device | Faible (validation rapide lors du premier run device) |
| LazyVStack pour relations SwiftData | 1.2 | Accepté — données volumineuses improbables MVP | Faible |
| NFR-P3 ≤ 500ms non mesurée formellement | 1.2 | Accepté — UI launch test couvre le cas | Faible |

---

## Aperçu Épic 2 et dépendances

**Épic 2 — Mode Chantier : Capture Vocale et Photo** (5 stories restantes : 2.2 → 2.6)

Story 2.1 déjà `done` ✅

**Dépendances sur Épic 1 :**
- `ModeChantierState` ✅ (sessionActive, tacheActive, boutonVert, isBrowsing)
- `NavigationStack` + `PauseBannerView` ✅
- `TacheEntity` + statuts ✅
- Architecture MVVM injectable ✅ (pattern BriefingEngine réutilisable)

**Nouveau territoire technique :**
- `AVAudioSession` + `AVAudioRecorder` + `SFSpeechRecognizer`
- `BigButton` composant avec pulse ~60fps piloté par `averagePower`
- `AudioEngineProtocol` (même pattern que BriefingEngine)
- Test obligatoire sur device physique (pas simulateur)

**Pas de découverte majeure qui remet en question le plan de l'Épic 2.** La navigation résolue (`.navigationDestination(for:)` supprimé) est cohérente avec l'Épic 2 qui utilise `fullScreenCover` piloté par `ModeChantierState.sessionActive`.

---

## Actions — Processus & Qualité

### Action 1 — Checklist règles non-négociables dans les stories
**Description :** Ajouter une section "Vérification avant review" dans chaque story : liste des règles non-négociables à cocher manuellement (try explicite, pas de mutation directe d'état partagé, pas de logique dans les Views).
**Propriétaire :** Bob (SM) — intégré dans la préparation des stories dès 2.2
**Critère de succès :** Zéro violation HIGH de règle non-négociable en revue de code

### Action 2 — Tests cas d'erreur comme condition de "done"
**Description :** Chaque story doit couvrir au moins un cas `.failure` ou rollback explicite dans ses tests. Si absent, la story n'est pas `done`.
**Propriétaire :** Dana (QA) — intégré dans la définition de done
**Critère de succès :** Zéro review qui signale "aucun test de cas d'erreur"

### Action 3 — Valider NFR-P1 sur device physique (dette story 1.1)
**Description :** Confirmer temps de lancement ≤ 1 seconde sur iPhone réel lors du premier run device.
**Propriétaire :** Nico — lors du premier déploiement pour story 2.2
**Critère de succès :** ≤ 1s confirmé, ou issue ouverte si dépassé

---

## Préparation Épic 2 — Tâches critiques avant story 2.2

**[ ] CRITIQUE — Valider device physique dans Xcode**
Brancher iPhone en USB → vérifier qu'il apparaît comme destination de build dans Xcode. Si demande de trust ou renouvellement profil → traiter immédiatement.
Propriétaire : Nico

**[ ] CRITIQUE — Vérifier pack linguistique français offline sur device**
`SFSpeechRecognizer` avec `requiresOnDeviceRecognition = true` nécessite le pack FR téléchargé. Réglages → Général → Langue et région → vérifier disponibilité offline.
Propriétaire : Nico

**[ ] À FAIRE — Relire story 2.2 en détail avant implémentation**
Story 2.2 = story la plus complexe de l'épic (AudioEngine protocol + BigButton pulse + persistence incrémentale). Lecture attentive des Technical Notes avant de coder.
Propriétaire : Nico

---

## Bug découvert lors des tests sur device — résolu post-rétrospective

### Crash + dysfonctionnement saisie vocale dans TaskCreationView (2026-02-25)

**Symptômes initiaux :** Après accord de la permission microphone, l'app se freezait (aucun contrôle cliquable). Kill + relaunch → écran blanc. Non reproductible sur simulateur.

**Processus de débogage en 4 étapes :**

#### Étape 1 — `EXC_BREAKPOINT` `_dispatch_assert_queue_fail` Thread 4
- **Cause :** Le callback `installTap` s'exécutait sur le thread audio et accédait à `self?.recognitionRequest` — `self` étant `@MainActor`, cet accès depuis le thread audio déclenche `dispatch_assert_queue`.
- **Fix :** Capturer `request` directement au lieu de `self` dans le closure `installTap`.
- **Résultat :** Crash persistant.

#### Étape 2 — `AVAudioEngine` + `SFSpeechRecognizer.requestAuthorization` sur le main thread
- **Cause :** `requestAuthorization` et `AVAudioSession.setCategory` appelés depuis `@MainActor` bloquaient le main thread sur device physique.
- **Fix :** Extraction de `requestSpeechAuthorization()` en `nonisolated static func`, audio setup déplacé dans `Task.detached`.
- **Résultat :** Watchdog iOS → "Lost connection to debugger".

#### Étape 3 — Watchdog iOS (main thread bloqué par `AVAudioEngine.start()`)
- **Cause :** `AVAudioEngine.inputNode` et `start()` bloquent sur hardware réel. Sur simulateur : imperceptible. Sur device : watchdog ≈ 8s.
- **Tentative :** `nonisolated(unsafe)` sur les propriétés audio de `TaskCreationViewModel` → build fail : non valide sur les `var` d'une classe `@MainActor`.
- **Fix final :** Refactoring complet avec `AudioState: @unchecked Sendable` — classe interne isolée qui détient tout l'état AVAudio/Speech, capturée par `Task.detached` sans passer par `self`.
- **Résultat :** Build réussi. L'app ne crashe plus. Mais la transcription ne fonctionne pas.

#### Étape 4 — `SFSpeechRecognizer.recognitionTask(with:)` appelé hors main actor
- **Cause :** Dans le `Task.detached`, `recognizer?.recognitionTask(with: req)` était appelé depuis un contexte nonisolated. `SFSpeechRecognizer` est `@MainActor` dans le SDK Swift 6 — l'appel hors main actor retournait immédiatement une erreur silencieuse.
- **Symptôme :** Micro passait au rouge, clignotait 1-2 fois (error callback), revenait à l'état initial. Rien n'était transcrit.
- **Fix final :** `recognitionTask(with:)` déplacé dans `await MainActor.run { }` — l'engine audio tourne off-main-actor (pas de watchdog), l'API SFSpeechRecognizer est appelée sur le main actor.
- **Résultat :** ✅ Transcription fonctionnelle sur device physique.

**Architecture finale de `TaskCreationViewModel.swift` :**
```swift
// AudioState: @unchecked Sendable — détient tout l'état audio off-main-actor
private final class AudioState: @unchecked Sendable {
    nonisolated(unsafe) let engine = AVAudioEngine()
    nonisolated(unsafe) var recognizer: SFSpeechRecognizer? = ...
    var request: SFSpeechAudioBufferRecognitionRequest?
    nonisolated(unsafe) var recognitionTask: SFSpeechRecognitionTask?
    var silenceTimer: Timer?
    var activeField: TaskCreationViewModel.Field?
}

// beginCapture : audio setup off-main-actor, recognitionTask sur main actor
Task.detached {
    // AVAudioSession + AVAudioEngine.start() — off main actor (évite watchdog)
    try audioState.engine.start()

    await MainActor.run {
        // SFSpeechRecognizer.recognitionTask() — sur main actor (requis par @MainActor SDK)
        audioState.recognitionTask = audioState.recognizer?.recognitionTask(with: req) { ... }
    }
}
```

**Leçons clés pour l'Épic 2 (story 2.2 — AudioEngine) :**

1. **`installTap` callback → thread audio** : ne jamais accéder à `self` (`@MainActor`). Capturer uniquement les valeurs primitives nécessaires.
2. **`AVAudioEngine.start()` → off main actor** : bloque le main thread sur device physique → watchdog iOS. Toujours appeler depuis `Task.detached` ou une DispatchQueue dédiée.
3. **`SFSpeechRecognizer.recognitionTask(with:)` → main actor** : l'API est `@MainActor` dans le SDK Swift 6. Appel hors main actor = erreur silencieuse immédiate.
4. **`@unchecked Sendable` + `nonisolated(unsafe)`** : pattern valide pour faire traverser les frontières d'acteurs aux types AVFoundation/Speech non-Sendable. Valide sur une classe non-`@MainActor` uniquement (`nonisolated(unsafe)` est refusé sur les `var` d'une classe `@MainActor`).
5. **`@preconcurrency import AVFoundation` / `import Speech`** : supprime les erreurs Sendable du SDK mais PAS les erreurs d'isolation `@MainActor` — les deux mécanismes sont distincts.

---

## Chemin critique avant de démarrer story 2.2

1. Device physique reconnu par Xcode ✓
2. Pack FR speech recognition disponible offline ✓
3. Bug saisie vocale (EXC_BREAKPOINT) résolu ✓
4. NFR-P1 validé (ou issue ouverte) ✓

---

## Prochaines étapes

1. **Exécuter les tâches critiques de préparation** (device physique + pack linguistique)
2. **Démarrer story 2.2** avec l'agent SM (create-story ou implémentation directe)
3. **Appliquer les nouvelles règles** dès 2.2 : checklist règles non-négociables + tests cas d'erreur obligatoires

---

Bob (Scrum Master) : "Épic 1 livré à 100%, fondation solide, équipe alignée. Prêts pour l'Épic 2."
